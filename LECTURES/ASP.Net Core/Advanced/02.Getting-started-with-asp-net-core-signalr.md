# Getting Starting with ASP.NET Core SignalR

- Overview
-- Two Parts
--- Server Side
--- Client Side
-- Concepts in this course
--- Real-time web concepts
--- Concepts of SignalR
--- Implementing a SignalR app

## Understanding the Realtime WEB Application

- What are rela-time web applications
-- Email clients (GMAIL) don't have to refresh the page when an new email arrives
-- Twitter Posts
-- Web Documents
-- Auctions
-- FaceBook Notifications, .etc
-- Stock Pricing Sites
-- SignalR transports => Polling, Long Polling, Server Sent Events (SEE), and WebSockets

- Transports
-- Web Sockets
-- Server Sent Events
-- Long Polling
-- Remote Procedure Call (RPC)
-- Hubs => A hub is a server-side class that sends messages to and receives messages from clients
-- Scaling Out
-- Azure SignalR Service

# Working with ASP.Net Core SignalR

- Implementing a Hub
- Configuring SignalR
- Using hubs in your application
- Authentication and authorization
- Creating a browser client
- Transport negotiation
- Creating a .NET Client
- Configuring MessagePack
- Deploying
- Azure SignalR service

## To implement SignlaR on the client

- npm install @aspnet/signalr
- signal.js
- @types/signalr
- @aspnet/signalr-protocol-msgpack /// MessagePack Protocol
-- https://4sh.nl/signalrmessagepack
- Sample Front End Code for SignalR Hub Interaction with client
setupConnection = () => {
    connection = new SignalR.HubConnectionBuilder()
        .withUrl('/coffee-endpoint', signalR.HttpTransportType.LongPolling) ///  signalR.HttpTransportType.WebSocket
        .AddMessagePackProtocol()
        .build();
    conneciton.on('ReceiveOrderUpdate', (update) => {
        statusDiv.innerHTML = update;
    });

    conneciton.on('NewOrder', (order) => {
        div.innerHTML = 'Someone ordered an ' + order.product;
    });

    conneciton.on('finished', () => {
        connection.stop();
    );

    connection.start()
        .catch(err => console.error(err.toString()));
};

setupConnection();

- Code to process from front end
fetch('/coffee', {
    method: 'POST',
    body: JSON.stringify({ product, size}),
    headers: {
        'content-type': 'application/json'
    }
})
.then(response => response.text())
.then(id => connectin.invoke('GetUpdateForOrder', id));

- MessagePack Protocol is not included in .NET SignalR
services.AddSignalR().AddMessagePackProtocol();

- To know the limit per applications, see url:
https://4sh.nl/appservicelimits

- Redis account will sync clients across servers
-- Microsoft.AspNetCore.SignalR.Redis
services.AddSignalR()
    .AddRedis() /// Uses app-settings ConnectionString or configuration settings
    .AddRedis(ConnectionString)
    .AddMessagePackProtocol();

- Azure SignalR
-- Pay for simultaneous connections
--- Microsoft.Azure.SignalR
services.AddSignalR()
    .AddAzureSignalR('Azure:SignalR:Connections')
    .AddMessagePackProtocol();

## Transport selection process
The following list shows the steps that SignalR uses to decide which transport to use.
1. If the browser is Internet Explorer 8 or earlier, Long Polling is used.
2. If JSONP is configured (that is, the jsonp parameter is set to true when the connection is started), Long Polling is used.
3. If a cross-domain connection is being made (that is, if the SignalR endpoint is not in the same domain as the hosting page), then WebSocket will be used if the following criteria are met:
    - The client supports CORS (Cross-Origin Resource Sharing). For details on which clients support CORS, see CORS at caniuse.com.
    - The client supports WebSocket
    - The server supports WebSocket
    - If any of these criteria are not met, Long Polling will be used. For more information on cross-domain connections, see How to establish a cross-domain connection.
4. If JSONP is not configured and the connection is not cross-domain, WebSocket will be used if both the client and server support it.
5. If either the client or server do not support WebSocket, Server Sent Events is used if it is available.
6. If Server Sent Events is not available, Forever Frame is attempted.
7. If Forever Frame fails, Long Polling is used.

## Specifying a transport
Negotiating a transport takes a certain amount of time and client/server resources. If the client capabilities are known, then a transport can be specified when the client connection is started. The following code snippet demonstrates starting a connection using the Ajax Long Polling transport, as would be used if it was known that the client did not support any other protocol:

connection.start({ transport: 'longPolling' });

You can specify a fallback order if you want a client to try specific transports in order. The following code snippet demonstrates trying WebSocket, and failing that, going directly to Long Polling.

connection.start({ transport: ['webSockets','longPolling'] });

The string constants for specifying transports are defined as follows:
- webSockets
- foreverFrame
- serverSentEvents
- longPolling
