# Building an Async API with ASP.Net Core

## Async Patterns: TAP, EAP, and APM
- EAP => Event-based Asynchronous Pattern (EAP)
-- Multithreading without the complexity
-- MethodNameAsync
-- MethodNameCompleted
-- MethodNameAsyncCancel

- APM => Asynchronous Programming Model (APM)
-- Async operations are implemented as two methods named:
--- BeginOperationname
--- EndOperationName

- TAP => Task-based Asynchronous Pattern (TAP)
-- Best Practice today
-- Based on:
--- Task
--- Task<T>
--- GetAwaiter() - implementing Types

- ASYNC/AWAIT improves scalability

## Why Cancellation Matters
- Frees up threads (I/O bound work)
-- Improves scalability
- Frees up CPU Resources (computational bound work)

## Avoid Common Pitfalls
- Offloading Legacy Code to a Background
-- Legacy code, like long-running algorithms, is computational bound code
-- These can be offloaded to a background thread using async/await
--- Can run concurrently

1. Pitfall #1: Using Task.Run() on the Server
- ASP.Net Core is not optimized for Task.Run()
-- Creates an unoptimized thread
-- Causes overhead
- Decreases scalability
- GREAT FOR WPF/XAMARIN and NOT APIs/WEB APPs
2. Pitfall #2: Blocking Async Code
- Calling the Ressult property
var bookEntities = _repository.GetBooksAsync().Result;
- Task.Wait() and Task.Result() block the calling thread
-- Can not return to the thread pool
-- Avoid this
- ASP.Net Core doesn't have a synchronization context (the old ASP.Net does)
-- Improve performance
-- Makes it easier to write async code
-- Synchronization Context leads to deadlocks
3. Pitfall #3: Modifying Shared State
- Very unsafe in ASP.Net Core
- Different threads might manipulate the same state at the same time
-- Correctness cannot be guaranteed

