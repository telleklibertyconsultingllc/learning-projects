# Building an API with ASP.Net Core

## Course Overview

- Creating an API with ASP.NET Core
- Creating API Controllers
- Querying and Modifying Data
- Using Association Controllers
- Defining Operational APIs
- Versioning APIs with MVC 6

## REST - REpresentational State Transfer

- Concepts Include:
-- Separation of Client and Server
-- Server Requests are Stateless
-- Cacheable Requests
-- Uniform Interface

- Problems
-- Too difficult to be qualified as "REST"
-- Dogma of REST VS Pragmatism
--- Structured architectural style that may not fit in every domain
--- The need to be productive
-- Any rigorous will backfire on the architecture
--- Building the architecture is meet the needs of the people/business. You may bend at times.

## What are Resources?

- People/invoices/payments/products
- Things that represents the things in your system
-- Models
-- Entities
-- Domain
- Everything in a context inside a resource
- Endpoints to resources
- Resources and Entities are not the same and sometimes they are

## Designing the API

- URIs are just paths to Resources
-- api.yourserver.com/people
- Query Strings for non-data elements
-- api.yourserver.com/people?name=John&day=tuesday

- Design
-- Create the model

## Design the URI

- http://.../api/camps
- http://.../api/camps/ATL2018
- http://.../api/camps/ATL2018/talks
- http://.../api/camps/ATL2018/talks?topic=database
- http://.../api/camps/ATL2018/talks/1
- http://.../api/camps/ATL2018/talks/1/speaker
- http://.../api/reloadconfig

- Status Codes
-- 200 OK
-- 201 Created
-- 202 Accepted
-- 302 Found
-- 304 Not Modified
-- 307 Temp Redirect
-- 308 Perm Redirect
-- 400 Bad Request => Client/Consumer did something bad
-- 401 Not Authorized
-- 403 Forbidden
-- 404 Not Found
-- 405 Method Not Allowed
-- 409 Conflict
-- 500 Internal Error => API Developer did something wrong
-- >500 Custom Errors

## Http Verbs

- Get
- Post
- Delete
- Put
- Patch

## Model Binding

- POST => FromBody Attribute or add ApiController Attribute at the class level
-- POST Method requires to return a new value
--- Created() ActionResult
--- LinkGenerator available in ASP.Net Core

```<c#>
public async Task<IActionResult> Post(Camps model) {
    var location = _linkGenerator.GetPathByAction("Get", "Camps", new { moniker = model.Moniker });
    if (string.IsNullOrWhiteSpace(location)) {
        return BadRequest("");
    }
    return Created(location, model);
}
```

## Moidel Validation Attributes

- Require
- Range(1, 100)
- StringLength(100)
- Custom Validation Attributes

```<c#>
    if (camp != null) {
        return BadRequest();
    }
    if (!ModelState.IsValid) {
        return BadRequest();
    }
    return OK();
```

## PUT

- updates all fields on model with the id or value to update

```<c#>
    [HttpGet("{moniker}")]
    public async Task<ActionResult<CampModel>> Put(string moniker, CampModel model) {
        var oldCamp = await _repository.GetCampAsync(moniker);
        if (oldCamp == null) {
            return NotFound("Could not find camp with moniker");
        }
        /// Write changes from model sent by consumer to DB model
        _mapper.Map(model, oldCamp);
        if (await _repository.SaveChangesAsync()) {
            return _mapper.Map<CampModel>(oldCamp);
        }
        return BadRequest(); /// OR Something
    }
```

## PATCH

- Updates some fields on model with the id or value to update

## DELETE

- Deletes an entity or resource from the DB

```<c#>
    [HttpDelete("{moniker}")]
    public async Task<IActionResult> Delete(string moniker) {
        _repository.Delete(oldCamp);

        if (await _repository.SaveChangesAsync()) {
            return OK();
        }
        return BadRequest();
    }
```

## Creating Association APIs

- Controllers
-- Camps
-- Talks

## Functional APIs

- REST defines URIs as resources
-- But exceptions exit...
--- don't be afraid of functional APIs

- When should you use Functional APIs
-- Operational needs that are not around resources
-- Clearing the cache
-- Reload a configuration

- APIs on the Web
-- verbs included in API
-- Pragmatic REST
--- URI Endpoints
--- Resource URIs
--- Http Verbs
--- Stateless Server
--- Content Negotiation
-- Link Relations
--- Hypermedia

## Versioning

- Query Strings or URL
- Headers (Accept Header)
- Content Type

## Introducing Versioning

- Nuget Package for Versioning
-- Microsoft.AspNetCore.Mvc.Versioning
- To Make Versioning Work
-- Implementing Versioning

```<c#>
    1.
    services.AddApiVersioning(opt => {
        opt.DefaultApiVersion = new ApiVersion(1, 1);
    opt.ReportVersions = true;
    });

    2.
    services.AddMvc(opt => opt.EnableEndpintRouting = false).SetCompatibilityVersion(CompatabilityVersion.version_2_2);
```

-- Versioning Actions with URLS

```<c#>
    services.AddApiVersioning(opt => {
        opt.DefaultApiVersion = new ApiVersion(1, 1);
        opt.ReportVersions = true;
        opt.ApiVersionReaer = new QueryStringApiVersionReader();
    });
```

```<c#>
    [Route("api/[controller]")]
    [MapToApiVersion("1.0")]
    [MapToApiVersion("1.1")]
    [ApiController]
    public class MapsController: ControllerBase {

        [MapToApiVersion("1.1")]
        public async Task Get11() {

        }
    }

    /// Note the Route name does not follow api/[controller]
    [Route("api/camps")]
    [MapToApiVersion("2.0")]
    [ApiController]
    public class Maps2Controller: ControllerBase {

        public async Task Get11() {

        }
    }
```

-- Versioning Actions with Headers
--- Required additional level of complexity.
--- Adding to the URL might be less complex

```<c#>
    services.AddApiVersioning(opt => {
        opt.DefaultApiVersion = new ApiVersion(1, 1);
        opt.ReportVersions = true;
        opt.ApiVersionReaer = new HeaderApiVersionReader("X-version");
    });
```

```<c#>

```

-- Using Multiple Version Methods

```<c#>
    services.AddApiVersioning(opt => {
        opt.DefaultApiVersion = new ApiVersion(1, 1);
        opt.ReportVersions = true;
        /// This means specify either-or header, query string
        opt.ApiVersionReaer = ApiVersionReader.Combine(
            new HeaderApiVersionReader("X-version"),
            new QueryStringApiVersionReader("X-version"),
            new UrlSegmentApiVersion()
        );
    });
```

-- URL Versioning
--- NOT Good, have to support that specific URL
--- Not easy to remove api/v1/camps to api/v2/camps
--- Have to change all URLS, possibly

```<c#>
    services.AddApiVersioning(opt => {
        opt.DefaultApiVersion = new ApiVersion(1, 1);
        opt.ReportVersions = true;
        /// This means specify either-or header, query string
        opt.ApiVersionReaer = ApiVersionReader.Combine(
            new HeaderApiVersionReader("X-version"),
            new QueryStringApiVersionReader("X-version"),
            new UrlSegmentApiVersion()
        );
    });
```

```<c#>
    [Route("api/v{version:apiVersion}/camps")]
```

-- Versioning Conventions

```<c#>
    /// Centralized all of your versioning
    services.AddApiVersioning(opt => {
        opt.Conventions.Controller<TalksController>()
            .HasApiVersion(new ApiVersion(1, 0))
            .HasApiVersion(new ApiVersion(1, 0))
            .Action(c => c.Delete(default(string), default(int)).
                MapToApiVersion(1, 0));
    });
```

-- Other Versioning Methods
--- Versioning by Namespaces
--- Versioning With Content Type
--- Writing your own Readers
--- Writing your own Resolvers
