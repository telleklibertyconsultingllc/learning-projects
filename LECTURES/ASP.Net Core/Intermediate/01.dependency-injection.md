# Dependency Injection in ASP.Net Core

## Course Overview

- Dependency Injection container features
- Correctly register services
- Resolve Services
- Extend and replace the built-in container

## Registering your fiest Service

- Improving an application with dependency injection
-- Identify design problems
-- Refactor to depend on abstractions
-- Support dependency injection
-- Register our first service

- ASP.Net Core Foundational Concepts
-- ASP.Net Core MVC
-- Logging
-- Configuration
-- Hosting
-- Dependency Injection

### Coding to Interfaces

- Avoid manual instantion of classes
- Code classes to Abstractions
-- Abstract to interfaces

### Inverting Control with Construction Injection

- With constructor injection we define the list of required dependencies as parameters of the constructor for a class

```<c#>
    private readonly IWeatherForecaster _weatherForecaster;

    public HomeController(IWeatherForecaster weatherForecaster) {
        _weatherForecaster = weatherForecaster;
    }

    [Route("")]
    public IActionResult Index() {
        var currentWeather = _weatherForecaster.GetCurrentWeather();
    }
```

### Registering Your First Service

- Use IServiceCollection is used to register services
-- Services collected will be resolvable in the IServiceCollection
- Process
-- ConfigureServices method Using the IServiceCollection
-- Put in the Startup class
--- Has two methods
---- ConfigureServices => to register all services
----- Register all services at the top of the method
---- Configure => configures environment

### Benefits of Dependency Injection

- Promotes loose coupling of components
- Promotes logice abstraction of components
- Supports unit testing
- Cleaner, more readable code

## The Microsoft Dependency Injection Container

- The Microsoft DI Container
-- HostingEnvironment
-- Logging
-- Configuration
-- Routing
-- MVC
-- ApplicationLifetime
-- Custom Built-in Services

- Dependency Injection Containers
-- Register when ASP.Net Core is started up
-- Resolved during runtime

- Components
-- IServiceCollection => Register services
-- IServiceProvider => Resolve service instances

### What to Register with the DI Container

- Identifying Dependencies
-- Locate "new" keyword usage
-- Is the object a dependency?
-- Apply dependency inversion
-- Register the service
-- Rinse and repeat

- Dependency Graphy => a hierarchy of dependencies in a class diagram
- Plain Old CLR Objects - POCO
-- Are not dependencies
-- Use new on View Models or Data Type Models (DTO)

- Poor candidates for DI Container
-- Primitive Types and Strings
-- Prefer the strongly-typed options pattern => configuration services

### Accessing Configuration from a Controller

- Options Pattern
-- Define a POCO (DTO/View-Model) to hold settings

```<c#>
    /// POCO Class FeaturesConfiguration
    public class FeaturesConfiguration {
        public bool EnableWeatherForecast { get; set; }
    }

```

```<c#>
    /// appsettings.json
    "Features": {
        "EnableWeatherForecast": true
    }

```

```<c#>
    /// Register your configuration Services
    public void ConfigureServices(IServiceCollection services) {
        services.Configure<FeaturesConfiguration>(Configuration.GetSection("Features"));
    }

```

```<c#>
    /// Using the Configuration Service
    public HomeController(
        IWeatherForecaster weatherForecaster,
        IOptions<FeaturesConfiguration> options
    ) {
        _weatherForecaster = weatherForecaster;
        _featuresConfiguration = options.Value;
    }

    [Route("")]
    public IActionResult Index() {
        if (_featuresConfiguration.EnableWeatherForecast) {
            /// DO SOMETHING!
        }
    }

```

### Service Lifetimes

- Service Lifetime determines how long a service object will live for during the lifetime of the service
- Types of Service Lifetimes
-- Transient => Created each time they are requested
-- Singleton => Created once for the lifetime of the application
-- Scoped => Created once per request
- The chosen lifetime affects the creation and reuse of service instances

#### Transient Services

- A new instance is created every time the service is resolved
-- DI Container => every class that request a service from the DI container, a new instance is returned
-- Not required to be thread-safe
-- Potentially less efficient => More work for the garbage collector. Safest choice when Service lifetime is not known

#### Singleton Services

- One shared instance for the lifetime of the application
- DI Container => same instance will be used in all classes in the API
- Generally more performant
-- Allocates less objects
-- Reduces load on GC
- Must be thread-safe
- Suited to functional stateless services
-- Memory Cache is a perfect example
- Consider frequency of use VS memory consumption
-- if used infrequently, a singleton class is not a good option

#### Scoped Services

- Scope Services sits between Transient and Singleton; Scoped services return an instance per scope for a request.
-- Every requests returns a new service
- DI container => Rquest1 will receive the same services for this request (request1), same idea for request2, .etc

### Safe Dependencies

-           Transient   Scoped  Singleton
- Transient   Yes         Yes     Yes
- Scoped      No          Yes     Yes
- Singleton   No          No      Yes

- Scope Validation
-- Enabled by default in development
-- Validates container scopes at startup

```<c#>
    /// Can configure scope validation in Program.cs in ASP.Net Core API
    public class Program {
        public static void Main(string[] args) {
            CreateWebHostBuilder(args).Build().Run();
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) => 
            WebHost.CreateDefaultBuilder(args)
                .UseDefaultServiceProvider(options => {
                    options.ValidateScopes = true;
                });
    }
```

## Registering More Complex Services

- Service Descriptors contain information about registered services
-- ServiceDescriptor class
--- ServiceType => very rare to work directly with this service (there are scenarios where you would want to work with this class)
--- ImplementationType
--- LifeTime

- Options for Working with the ServiceDescriptor class

```<c#>
    /// Option 1
    var serviceDescriptor = new ServiceDescriptor(
        typeof(IWeatherForecaster), /// interface
        typeof(WeatherForecaster),  /// Implementation class
        ServiceLifetime.Singleton   /// Service Lifetime
    );

    /// Option 2
    var serviceDescriptor = ServiceDescriptor.Describe(
        typeof(IWeatherForecaster), /// interface
        typeof(WeatherForecaster),  /// Implementation class
        ServiceLifetime.Singleton   /// Service Lifetime
    );

    /// Option 3
    var serviceDescriptor = ServiceDescriptor.Singleton(
        typeof(IWeatherForecaster), /// interface
        typeof(WeatherForecaster),  /// Implementation class
        ServiceLifetime.Singleton   /// Service Lifetime
    );

    /// Option 4
    var serviceDescriptor = ServiceDescriptor.Singleton<IWeatherForecaster, WeatherForecaster>();

    /// Register service descriptor
    services.Add(serviceDescriptor);
```

- USE EXTENSION METHODS ON THE SERVICECOLLECTION OBJECT INSTEAD OF USING THE SERVICEDESCRIPTOR CLASS DIRECTLY!!!

### Add VS TryAdd

- Most common methods => AddTransient, AddScoped, AddSingleton
- When there is multiple registration of the same service, the last one is used
-- If registration gets complex, multiple services may be registered
- TryAdd is the same as Add (Microsoft.AspNetCore.Dependency.Extensions)
-- Attempts to register a second instance of the same type. If registered, it won't register the service again, unlike Add method.
-- Consider using the TryAdd methods

### Registering an Interface Multiple Times

- What happen to the first registration when multiple registration occurs?
-- Two Add Registrations
--- services.AddSingleton<IClass, Class1>();
--- services.AddSingleton<IClass, Class2>();
-- Both classes above are available
-- Last will be resolved

### Replacing and Removing Registration Services

- Replace removes the first occurrence of the IClass interface
-- services.Replace(ServiceDescriptor.Singleton<IClass, Class2>()); /// Verify rare situation where you provide a service descriptor
- RemoveAll removes all occurrences of the IClass interface
-- services.RemoveAll<IClass>();

### Registering Multiple Implementation of an Interfaces or Service Type

- There may be situations where you may find it useful to register multiple service types

```<c#>
    /// Registration
    services.TryAddSingleton<IBookingConfiguration>(sp =>
        sp.GetRequiredService<IOptions<BookingConfiguration>>().Value);
    /// Notification Services
    services.AddSingleton<INotificationService>(sp =>
        new CompositeNotificationService(
            new INotificationService[] {
                sp.GetRequiredService<EmailNotificationService>(),
                sp.GetRequiredService<SmsNotificationService>(),
                sp.GetRequiredService<EmailNotificationService>(),
                sp.GetRequiredService<MessagingNotificationService>(),
            }
        ));

    /// Using a Builder Class
    services.AddScoped<IMembershipAdvert>(sp => {
        var builder = sp.GetService<IMembershipAdvertBuilder>();
        builder.WithDiscount(10m);
        return builder.Build();
    });

    /// Usage
    class Name {
        private readonly IBookingConfiguration _bookingConfiguration;
        private IEnumerable<INotificationService> _notificationsService;
        public MaxNotification(IEnumerable<INotificationService> notificationsService) {
            _notificationsService = notificationsService;
        }

        public void Notify(string message) {
            forEach(var svc in _notificationsService) {
                svc.Notify(message);
            }
        }
    }
```

### Registering an Implementation Against Multiple Service Types

- Why register an implementation against multiple service types?
- How to register an implementation multiple times

### Registering Open Generics

- Example could be caching services

```<c#>
    /// Caches Open Generics.
    /// Don't specify the Generic Type
    /// See below
    services.TryAddSingleton(typeof(IDistributedCache<>), typeof(DistributedCache<>));
```

### Clean Code Using Extensions

```<c#>
    /// Use Extension Classes
    namespace Microsoft.Extensions.DependencyInjection {
        public static class ConfigurationServiceCollectionExtension {
            public static IServiceCollection AddAppConfiguration(this IServiceCollection services, IConfiguration config) {
                /// Put all code below for Configurations
                /// Code...
                return services;
            }

            public static IServiceCollection AddBookingServices(this IServiceCollection services) {
                /// Put all code below for Configurations
                /// Code...
                return services;
            }
        }
    }

    /// Implementation or Usage
    public void ConfigureServices(IServiceCollection services) {
        services.AddAppConfiguration(Configuration)
            .AddBookingServices();
    }
```

## Injecting and Resolving Dependencies

- Construction Injection
- Action Injection
- Middleware Injection
- View Injection
- Advanced Scenarios for Resolving Services

### Service Resolution Mechanisms

- IServiceProvider
- ActivatorUtilities
-- Create an object via its constructor
-- Arguments can be supplied directly or resolved from an IServiceProvider
-- Used to activate framework components

### Constructor Injection

- Controllers
- Razor page models
- ViewComponents
- TagHelpers
- Filters
- Middleware

- Constructor Rules
-- Assign default values for arguments not provided by the container
-- When services are resolved, a public constructor is required
-- Only a single applicable constructor can exist for services resolved via ActivatorUtilities
   (framework components such as controllers)

```<c#>
    /// Demonstrate last rule
    1. Controller inject services with multiple constructors
    2. All Services must be registered using ConfigureServices in Startup class
```

### Action Injection

- Used in Action Methods

```<c#>
    public async Task<ActionResult> UpcomingMaintenance([FromServices] ICourtMaintenanceService courtMaintenanceService) {
        var maintenanceSchedules = await courtMaintenanceService.GetUpcomingMaintenance();
        /// Code below...
    }
```

### Injecting Services into Middleware

- Middleware Services are constructed once, meaning, they are singleton. Are capture for the lifetime of the application
-- Don't use AddScope
-- If using in a Service, don't use Scope or Transient Service Lifetime, always use Singleton

- Services Constructor                     Invoke/InvokeAsync (Middleware)
-- Runs once for the lifetime of        <=> Runs once per request
   the application
-- Supports only singleton services     <=> Services are resolved from the request scope
-- Scoped or transient services will    <=> Supports all service lifetimes
   be captured and may not behave
   correctly

- Factory-based middleware is constructed once per request

### Creating and Using Scopes

- Manually creating a scope
- Resolving services from a custom scope
-- Done in the Program.Main method

## Beyond the Built-in Container

- Built-in Container is not enough for handling calls
- Look at: (Srutor is used for Assembly Scanning; use instead of .Net Core Dependency Injection IServiceCollection)
-- At runtime it will scan and register all services within an Assembly/DLL
--- Extending the container using Scrutor => provides support for Assembly Scanning
--- https://github.com/khellang/scrutor
-- Scanning for Services
-- Decorating services

- Problem
-- Make all rules Scoped or one Lifetime

```<c#>
    /// Scrutor Dependency Injection
    services.Scan(scan =>
        scan.FromAssemblyOf<IActionResult>()
        .AddClasses(c => c.AssignableTo<IActionResult>())
        .AsImplementedInterfaces()
        .WithScopedLifetime()
    );
```

- Solution

```<c#>
    /// Scrutor Dependency Injection
    services.Scan(scan =>
        scan.FromAssemblyOf<IScopeCourtBookingRule>()
        .AddClasses(c => c.AssignableTo<IScopeCourtBookingRule>())
            .As<ICourtBookingRule>()
            .WithScopedLifetime()
        .AddClasses(c => c.AssignableTo<ISingletonCourtBookingRule>())
            .As<ICourtBookingRule>()
            .WithSingletonLifetime()
    );
```

- Applying the Decorator Pattern with Scrutor
-- Caching Service

```<c#>
    /// Registration Class
    public static class WeatherServiceCollectionExtensions {
        public static IServiceCollection AddWeatherForecasting(this IServiceCollection services) {
            services.AddHttpClient<IWeatherApiClient, WeatherApiClient>();
            services.TryAddSingleton<IWeatherForecaster, WeatherForecaster>();
            /// When using Decorators, they are registered as the same Interface/Service Lifetime
            /// Example below will register the IWeatherForecaster as Singleton, like the one above
            services.Decorate<IWeatherForecaster, CacheWeatherForecaster>();
            return services;
        }
    }

    /// Usages
    public class CacheWeatherForecaster : IWeatherForecaster {
        public CacheWeatherForecaster(
            IWeatherForecaster weatherForecaster,
            IDistributedCache<CurrentWeatherResult> cache
        ) {
            _weatherForecaster = weatherForecaster;
            _cache = cache;
        }

        public async Task<CurrentWeatherResult> GetCurrentWeatherAsync() {
            /// First time, service will not be in the cache
            var cacheKey = $"current_weather_{DateTime.UtcNow:yyy_MM_dd}";
            var (isCached, forecast) = await _cache.TryGetValueAsync(cacheKey);
            if (isCached) {
                return forecast;
            }
            /// This will set the cache Service
            var result = await _weatherForecaster.GetcurrentWeatherAsync();
            await _cache.SetAsync(cacheKey, result, 60);
            return result;
        }
    }
```

- Replacing the built-in Dependency Injection Container

- Autofac (Similar to Scrutor)
-- Preferable to use with .Net Core or .Net Framework

```<c#>
    public class Program {
        public static async Task Main(string[] args) {

        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =>
            WebHost.CreateDefaultBuilder(args)
                .ConfigureServices(services =>
                    services.AddAutofac()
                )
                .UseStartup<Startup>();
    }

    public class Startup {
        public void ConfigureServices() {}
        public void Configure() {}

        /// Autofac
        public void ConfigureContainer(ContainerBuilder builder) {
            builder.RegisterType<CourtMaintenanceService>()
                .As<ICourtMaintenanceService>()
                .InstancePerLifetimeScope();
        }
    }
```
