# Using Configuration and Options in .Net Core and ASP.Net Core Apps

- Where to use configuration
- Configuration at runtime
- Options pattern
- Other configuration providers

## Getting Started with Configuration Concepts

- How to quickly begin leveraging configurations
-- How configuration is structured
-- Defining JSON configuration
-- Accessing configuration at runtime
--- Accessing by key
--- Accessing by section
--- Binding configuration
-- Overriding configuration by environment

### Application Configruation in .NET Core

- Configuration => same as environment.ts in Angular 10
- appsettings.json

#### Defining Configuration in JSON Files

```<c#>
    /// appsettings.json
    {
        "Features": {
            "HomePage": {
                "EnableGreeting": true,
                "EnableWeathreForecast": false,
                "ForecastSectionTitle": "What's the weather doing?"
            }
        }
    }

    /// IndexModel
    public IndexModel(IConfiguration configuration) {
        _configuration = configuration;
    }

    _configuration.GetValue<bool>("Features:HomePage:EnableGreeting");
```

#### Accessing Configuration Sections

```<c#>
    var homePageFeatures = _configuration.GetSection("Features:HomePage");
    ShowGreetings = homePageFeatures["EnableGreeting"];
```

#### Accessing Configuration at Startup

```<c#>
    public class Startup {
        public Startup(IConfiguration configuration) {
            Configuration = configuration;
        }

        public void ConfigureServices(IServiceCollection services) {
            options.UseSqlServer(
                configuration.GetConnectionString("DefaultConnection")
            );
        }
    }
```

- Use Extension Methods when using Startup class to configure services or perform any configuration

#### Binding Configuration

- Better than using the IConfiguration class in all your code

```<c#>
    public PageFeatures {
        public async Task OnGet() {
            var features = new Features();
            _configuration.Bind("Features:HomePage", features);

            if (features.EnableGreeting) {

            }
        }
    }
```

#### Loading Configuration Per Environment

```<c#>
    /// Environment Configuration
    appsettings.Development.json
    appsettings.Staging.json
    appsettings.QA.json

    /// Overrides
    "Features": {
        "HomePage": {
            "EnableGreeting": false
        }
    }
```

## Applying the Options Pattern

- Introducing the options pattern
-- IOptions<T>
-- IOptionsSnapshot<T>
-- IOptionsMonitor<T>
- Using named options
- Options validation

- IOptions => is a singleton

```<c#>
    public class HomePageConfiguration {
        public bool EnableGreeting { get; set; }
        public bool EnableWeatherForecast { get; set; }
        public bool ForecastSectionTitle { get; set; }
    }

    /// Constructor and Method
    public WeatherPage(IOptions<HomePageConfiguration> options) {
        _homePageConfigruation_ = options.Value;
    }

    public async Task OnGet() {
        if (_homePageConfigruation.EnableGreeting) {

        }
    }

    /// Failingh to configruation an options will not result in an error
    /// This is how to configure your section
    /// In the Startup class, do this
    public void ConfigureServices(IServiceCollection services) {
        services.Configure<HomePageConfiguration>(Configuration.GetSection("Features:HomePage"));
    }
```

- Reloading with IOptionsSnapshot<T>
-- If the configuration file is modified while the application is running the configuration is automatically reloaded
-- To make use of Options reloading, you must use through IOptionsSnapshot
-- This is a scope service lifetime

- IOptionsMonitor<T>
-- Safety Feature for Scope Validation
--- Can't use IOptionsSnapshot within a Singleton Service
---- Always use IOptionsMonitor

```<c#>
    private readonly IOptionsMonitor<GreetingConfiguration> _greetingConfiguraiton;

    public GreetingService(
        IOptionsMonitor<GreetingConfiguration> options
    ) {
        _greetingConfiguration = options;
        /// Usage
        Debug.WriteLine(_greetingConfiguration.CurrentValue.GreetingColor);

        /// Update code with latest configuration
        options.OnChange(config => {
            _greetingConfiguration = config;
        });
    }
```

#### Using Named Options

- Define named options
- Consume named options

```<c#>
    /// appsettings.json
    "ExternalServices": {
        "WeatherApi": {
            "Url": "http://localhost:62855",
            "MinsToCache": 10
        }
    },

    "Membership": {
        "MonthlyMembershipFullPrice": 25
    }

    public class ExternalServicesCnfig {
        public const string WeatherApi = "WeatherApi";
        public const string ProductsApi = "ProductsApi";

        public string Url { get; set; }
        public int MinsToCache { get; set; }
    }

    services.Configure<ExternalServicesConfig>("WeatherApi", Configuration.GetSection("ExternalServices:WeatherApi"));
    services.Configure<ExternalServicesConfig>("ProductsApi", Configuration.GetSection("ExternalServices:ProductsApi"));

    public class CacheWeatherForecaster: IWeatherForecaster {
        private readonly IWeatherForecaster _weatherForecaster;
        private readonly int _minsToCache;

        public bool ForecastEnabled => _weatherForecaster.ForecastEnabled;

        public CachedWeatherForecaster(
            IWeatherForecaster weatherForecaster,
            IOptionsMonitor<ExternalServicesConfig> options
        ) {
            _weatherForecaster = weatherForecaster;
            _externalServicesConfig = options.Value;
        }

        public async Task<CurrentWeatherResult> GetCurrentWeatherAsync() {

        }
    }
```

#### Applying Options Validation

```<c#>
    public class ExternalServicesCnfig {
        [Required]
        public string Url { get; set; }
        [Required]
        public int MinsToCache { get; set; }
    }

    /// Performs Validation during Startup
    services.AddOptions<HomePageConfiguration>()
        .Bind(Configuration.GetSection("Features:HomePage"))
        .ValidateDataAnnotations();

    /// Validation performance
    services.AddOptions<HomePageConfiguration>()
        .Bind(Configuration.GetSection("Features:HomePage"))
        .Validate(c => {
            if (c.EnableWeatherForecast && string.IsNullOrEmpty(c.ForecastSectionTitle)) {
                return false;
            }
            return true;
        });
```

```<c#>
    /// Register Validation in Startup Configure Method
    services.TryAddEnumerable(ServiceDescriptor.Singleton<IValidateOptions<HomePageConfiguration>, HomePageConfigurationValidation>())

    /// Validation Options
    public class HomePageConfigurationValidation : IValidateOptions<HomePageConfiguration> {
        private readonly IProfanityChecker _profanityChecker;
        private readonly bool _checkProfanity;
        private readonly WeatherForecastingConfiguration _weatherConfig;

        public HomePageConfigurationValidation(
            IOptions<ContentConfiguration> contentConfig,
            IOptions<WeatherForecastingConfiguration> weatherConfig,
            IProfanityChecker profanityChecker
        ) {
            _profanityChecker = profanityChecker;
            _weatherConfig = weatherConfig.Value;
            _checkForProfanity = contentConfig.Value.CheckForProfanity;
        }

        public ValidateOptionsResult Validate(string name, HomePageConfiguration options) {
            return ValidateOptionsResult.Fail("Error Message Failure");
        }
    }
```

## Other things to Consider

- Configuration Providers
-- How configuration is populated
-- Configuring applications using environment variables
-- Securing configuration secrets
--- Development - User secrets
--- Production - Azure Key Vault
-- Controlling configuration provider order
-- Defining a custom configuration provider
