# Microservices: The Big Picture

## What are Microservices?

- INTRODUCTION
- Microservices are technology-agnostic
- Compare Microservice with Monolithic Architecture
- Audience
-- Technical (Developer, Architect)
-- Business (CEO, CTO)

- SOFTWARE DEVELOPMENT LIFECYCLE
-- Waterfall or Agile => turns a project to product
-- Deployed in production

- MICROSERVICE DEFINITION
-- Set of Practices
-- Increase speed
-- Scale
-- Technology agnostic
-- Principles and architectural patterns

--- Micro => What's Big/Small?
---- Big or small
---- No universal measure
---- Does one thing and do it well
---- Scope of functionalities
---- Bounded Context
---- Identify sub-domains and develop each sub domain as a microservice
----- SDLC is the same for each sub domain
----- Smaller projects mean smaller teams
----- Each Microservice lives independently but they all interact together
----- All are deployed independently on the cloud, on-premise, .etc

--- Services
---- Independently deployable component
---- Interoperability
---- Message based communication
---- SOA is similar

- Important Requirement
-- It must be Micro
-- Bounded Context
-- Autonomously developed
-- Independently deployable
-- Exchange messages
-- Solve systems that are too big

-- Microservices => An approach to developing a single application as a suite of small services, each running in its own process.
-- Microservices are small, autonomous services that work together

- MONOLITH VS MICROSERVICES

## Microservices Elements

### Building a monolith

- Single monolith
- Single database
- Single API

- Pros
-- Simple to develop
-- Simple to build
-- Simple to test
-- Simple to deploy
-- Simple to scale

- Cons
-- New team members productivity
-- Growing teams
-- Code harder to understand
-- No emerging technologies

### Building Microservices

- Domain Driven Design
-- Domain consist of different parts of the business
-- Sub domains (like User, Orders, Planning, Execution, FileNet, HHS, Product)
-- Dependencies
--- Duplicate entities in sub domains
--- Each Sub domain should be responsible for its own model
--- Sharing databases should be discouraged in a microservice architecture

- Teams
-- Team Per Subdomain
--- Right-sized Teams
---- User
---- Product
---- HHS, .etc
-- Embrace agile and DevOps in each team

- Codebase
-- Documentation
-- Version Control Software
-- Repository
-- Each software is independent
-- Version

- Datastore
-- With Monolothic all data is stored in one database
-- With Microservice, this is an anti-pattern
--- Each Subdomain is independent
--- Different Requirements
--- Relational Database would be the best choice for database
--- NoSQL for unstructured data (GraphQL or LDAP Data)
--- Data Synchronization
---- Changes in one database have to be synchronized across other database (Monolithic)
---- With Microservices
----- No distributed transaction
----- Immediately consistent
----- Eventual consistency
----- Capture data change
----- Event sourcing
----- Akka, Kafka, Rabit MQ

- User Interface
-- With Microservices
--- Modular or Component-based UI
--- Independent teams
--- Own set of components
--- Unique UI for displaying multiple Microservices
--- UI Composition
---- Server side composition
---- Client Side composition
---- Have to be responsive

- Services
-- Packaged and deployed independently
-- Use API = Application Programming Interfaces
--- RPC = Remote Procedure Communication
---- Request/Reply (Request/Response)
---- Synchronous
---- Asynchronous
---- REST, SOAP, gRPC
--- Messaging or Event
---- Broker or channel
----- Publish a message
----- Other consumer subscribes to the Message
---- Loosely coupled
---- Protocal Format Exchange
----- XML, JSON, YAML
--- APIs and Contracts
---- API
---- Define your contracts using WSDL, Swagger, IDL (Interface Definition Language)
----- Devices
------ Different Devices
------ Different APIs and Contracts

- Distributed Services
-- Make sure the system is reliable
-- Service Registry
--- Locations changes
---- Use Service Registry is a phone book for services that looks up services
---- Self Registration
---- Discovery
---- Invocation
--- Cross-origin Resource Sharing
---- Same-origin policy
----- Only interacts with resources on the same-origin
----- origin is made up of protocol, server, port
---- Should talk to different origins
---- Restrict cross-origin
---- Use additional HTTP Headers
--- Circuit Breaker
---- Services available
---- Network Failure
---- Heavy load
---- Domino effect = one failure causes a failure in all the systems
----- Invoke via proxy
----- Deviate calls
----- Reintroduce traffic
--- Gateway
---- Access Individual Services
---- Single entry point
---- Unified interface
---- Cross-cutting concerns
---- API translation

- Security
-- Authorization
-- Authentication
-- Identity and Access Management System
--- Deligate authentication and authorization to the IAM System
--- Single sign-on => once signed in, don't have to sign in again
--- OAuth2.0, SAML, OpenID, Kerberos
-- Access Token
--- Send identity to other services through access token
--- Stores information about a user
--- Exchanged between services
--- JSON Web Token
--- cookie

- Scalability and Availability
-- Can scale microservices
--- Vertical Scaling = Adding more power to the machine (RAM/CPU)
---- Serveral Instances
---- Client Load Balancing
---- Registry
---- Round-robin, weight, capacity
--- Horizontal Scaling = Adding more hardware or computers
-- Availabilty
--- Probability for a system should be operational at a given time
--- Be operational
--- Single Point of Failure
--- Gateway
--- Broker
--- Registry
--- IAM
---- All instances must scale horizontally

- Monitoring
-- Monitoring and Dashboard
--- Many moving parts, many machines
--- Have to be centralized
--- Have to be visual (Kibana, Grafana, Splunk)
-- Health Check
--- Service running
--- Incapable handling request
--- Health check API
--- Database status
--- Host status
--- Health Checks are like heart beats
-- Log Aggregation
--- Understand behavior
--- Write Logs
--- Use a log aggregator = LogStash, Splunk, PaperTrail
-- Exception Tracking
--- Errors
--- Throw an exception
--- Exceptions should be recorded in a centralized exception system (Splunk)
-- Metrics
--- System slowing down
--- Performance issues
--- Gather Statistics
--- Aggregate these metrics (Azure, DropWizard)
-- Auditing
--- To understand the behavior of the users
---- Login/Logout/Visited Pages/Browsed Products/Record user activity
---- Azure
-- Rate Limiting
--- Third-Party access
--- Control API usage
--- Defend DoS attacks
--- Limit traffic
--- In a period of time
--- Monetize our APIs
-- Alerting
--- Tons of information
--- Fix error when occurs
--- Triggers alerts
-- Distributed Tracing
--- Request span services logs
--- Trace entire request
--- Correlation id
--- Creates a chain of calls
--- Dapper, HTrace, Zipkin => For distributed tracing

- Deployment
-- Azure/IIS/Cloud Provider
-- Physical server
-- On-premise
-- In the cloud
-- Deploy each Microservice on Multiple Services per Host
-- Container
--- Packaging microservice
--- With dependencies with container image (Docker/Kubernetes)
--- Easy to move from environment
--- Easy to scale up and down (Docker)
-- Orchestrator
--- Multiple containers on multiple machines
--- Start at the right time
--- Kubernetes is used for automating the tasks for deploying microservices
-- Continuous Delivery
--- Automate deployment
--- Cost-effective
--- Quick
--- Reliable
--- Build, test, deploy
--- Azure DevOps
-- Environments
--- Production/Development/Test/QA/Staging/Beta
--- Versioning should be taken into account
--- External Configuration
---- Different configurations for each environments
---- Activate functionality
---- Externalize configuration
---- Azure DevOps

## Are Microservices Right For Your Organization?
